/**
 * Generated by orval v7.21.0 üç∫
 * Do not edit manually.
 * NisshinRefine API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateStatusLogsRequest,
  CreateStatusLogsResponse,
  DeleteUsersUserId404,
  ErrorResponse,
  GetStatusStatusIdSummaryParams,
  GetUsersUserId404,
  PostUsers409,
  PostUsers500,
  PostUsersBody,
  PutUsersUserId404,
  PutUsersUserIdBody,
  StatusMetricsListResponse,
  StatusSummaryResponse,
  User
} from './model';


type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




export type postUsersResponse200 = {
  data: User
  status: 200
}

export type postUsersResponse409 = {
  data: PostUsers409
  status: 409
}

export type postUsersResponse500 = {
  data: PostUsers500
  status: 500
}
    
export type postUsersResponseSuccess = (postUsersResponse200) & {
  headers: Headers;
};
export type postUsersResponseError = (postUsersResponse409 | postUsersResponse500) & {
  headers: Headers;
};

export type postUsersResponse = (postUsersResponseSuccess | postUsersResponseError)

export const getPostUsersUrl = () => {


  

  return `/users`
}

export const postUsers = async (postUsersBody: PostUsersBody, options?: RequestInit): Promise<postUsersResponse> => {
  
  const res = await fetch(getPostUsersUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postUsersBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postUsersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postUsersResponse
}




export const getPostUsersMutationOptions = <TError = PostUsers409 | PostUsers500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: PostUsersBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: PostUsersBody}, TContext> => {

const mutationKey = ['postUsers'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsers>>, {data: PostUsersBody}> = (props) => {
          const {data} = props ?? {};

          return  postUsers(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postUsers>>>
    export type PostUsersMutationBody = PostUsersBody
    export type PostUsersMutationError = PostUsers409 | PostUsers500

    export const usePostUsers = <TError = PostUsers409 | PostUsers500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: PostUsersBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postUsers>>,
        TError,
        {data: PostUsersBody},
        TContext
      > => {

      const mutationOptions = getPostUsersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export type getUsersUserIdResponse200 = {
  data: User
  status: 200
}

export type getUsersUserIdResponse404 = {
  data: GetUsersUserId404
  status: 404
}
    
export type getUsersUserIdResponseSuccess = (getUsersUserIdResponse200) & {
  headers: Headers;
};
export type getUsersUserIdResponseError = (getUsersUserIdResponse404) & {
  headers: Headers;
};

export type getUsersUserIdResponse = (getUsersUserIdResponseSuccess | getUsersUserIdResponseError)

export const getGetUsersUserIdUrl = (userId: string,) => {


  

  return `/users/${userId}`
}

export const getUsersUserId = async (userId: string, options?: RequestInit): Promise<getUsersUserIdResponse> => {
  
  const res = await fetch(getGetUsersUserIdUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUsersUserIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUsersUserIdResponse
}





export const getGetUsersUserIdQueryKey = (userId?: string,) => {
    return [
    `/users/${userId}`
    ] as const;
    }

    
export const getGetUsersUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getUsersUserId>>, TError = GetUsersUserId404>(userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersUserId>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersUserId>>> = ({ signal }) => getUsersUserId(userId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersUserId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersUserId>>>
export type GetUsersUserIdQueryError = GetUsersUserId404



export function useGetUsersUserId<TData = Awaited<ReturnType<typeof getUsersUserId>>, TError = GetUsersUserId404>(
 userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersUserId>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type putUsersUserIdResponse200 = {
  data: User
  status: 200
}

export type putUsersUserIdResponse404 = {
  data: PutUsersUserId404
  status: 404
}
    
export type putUsersUserIdResponseSuccess = (putUsersUserIdResponse200) & {
  headers: Headers;
};
export type putUsersUserIdResponseError = (putUsersUserIdResponse404) & {
  headers: Headers;
};

export type putUsersUserIdResponse = (putUsersUserIdResponseSuccess | putUsersUserIdResponseError)

export const getPutUsersUserIdUrl = (userId: string,) => {


  

  return `/users/${userId}`
}

export const putUsersUserId = async (userId: string,
    putUsersUserIdBody: PutUsersUserIdBody, options?: RequestInit): Promise<putUsersUserIdResponse> => {
  
  const res = await fetch(getPutUsersUserIdUrl(userId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putUsersUserIdBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: putUsersUserIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as putUsersUserIdResponse
}




export const getPutUsersUserIdMutationOptions = <TError = PutUsersUserId404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putUsersUserId>>, TError,{userId: string;data: PutUsersUserIdBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putUsersUserId>>, TError,{userId: string;data: PutUsersUserIdBody}, TContext> => {

const mutationKey = ['putUsersUserId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putUsersUserId>>, {userId: string;data: PutUsersUserIdBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  putUsersUserId(userId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutUsersUserIdMutationResult = NonNullable<Awaited<ReturnType<typeof putUsersUserId>>>
    export type PutUsersUserIdMutationBody = PutUsersUserIdBody
    export type PutUsersUserIdMutationError = PutUsersUserId404

    export const usePutUsersUserId = <TError = PutUsersUserId404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putUsersUserId>>, TError,{userId: string;data: PutUsersUserIdBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putUsersUserId>>,
        TError,
        {userId: string;data: PutUsersUserIdBody},
        TContext
      > => {

      const mutationOptions = getPutUsersUserIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export type deleteUsersUserIdResponse200 = {
  data: User
  status: 200
}

export type deleteUsersUserIdResponse404 = {
  data: DeleteUsersUserId404
  status: 404
}
    
export type deleteUsersUserIdResponseSuccess = (deleteUsersUserIdResponse200) & {
  headers: Headers;
};
export type deleteUsersUserIdResponseError = (deleteUsersUserIdResponse404) & {
  headers: Headers;
};

export type deleteUsersUserIdResponse = (deleteUsersUserIdResponseSuccess | deleteUsersUserIdResponseError)

export const getDeleteUsersUserIdUrl = (userId: string,) => {


  

  return `/users/${userId}`
}

export const deleteUsersUserId = async (userId: string, options?: RequestInit): Promise<deleteUsersUserIdResponse> => {
  
  const res = await fetch(getDeleteUsersUserIdUrl(userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteUsersUserIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteUsersUserIdResponse
}




export const getDeleteUsersUserIdMutationOptions = <TError = DeleteUsersUserId404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersUserId>>, TError,{userId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsersUserId>>, TError,{userId: string}, TContext> => {

const mutationKey = ['deleteUsersUserId'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsersUserId>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUsersUserId(userId,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUsersUserIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsersUserId>>>
    
    export type DeleteUsersUserIdMutationError = DeleteUsersUserId404

    export const useDeleteUsersUserId = <TError = DeleteUsersUserId404,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersUserId>>, TError,{userId: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteUsersUserId>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUsersUserIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export type getStatusStatusIdResponse200 = {
  data: StatusMetricsListResponse
  status: 200
}

export type getStatusStatusIdResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getStatusStatusIdResponseSuccess = (getStatusStatusIdResponse200) & {
  headers: Headers;
};
export type getStatusStatusIdResponseError = (getStatusStatusIdResponse500) & {
  headers: Headers;
};

export type getStatusStatusIdResponse = (getStatusStatusIdResponseSuccess | getStatusStatusIdResponseError)

export const getGetStatusStatusIdUrl = (statusId: string,) => {


  

  return `/status/${statusId}`
}

export const getStatusStatusId = async (statusId: string, options?: RequestInit): Promise<getStatusStatusIdResponse> => {
  
  const res = await fetch(getGetStatusStatusIdUrl(statusId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getStatusStatusIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getStatusStatusIdResponse
}





export const getGetStatusStatusIdQueryKey = (statusId?: string,) => {
    return [
    `/status/${statusId}`
    ] as const;
    }

    
export const getGetStatusStatusIdQueryOptions = <TData = Awaited<ReturnType<typeof getStatusStatusId>>, TError = ErrorResponse>(statusId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusId>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatusStatusIdQueryKey(statusId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatusStatusId>>> = ({ signal }) => getStatusStatusId(statusId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(statusId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatusStatusIdQueryResult = NonNullable<Awaited<ReturnType<typeof getStatusStatusId>>>
export type GetStatusStatusIdQueryError = ErrorResponse



export function useGetStatusStatusId<TData = Awaited<ReturnType<typeof getStatusStatusId>>, TError = ErrorResponse>(
 statusId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusId>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStatusStatusIdQueryOptions(statusId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type getStatusStatusIdSummaryResponse200 = {
  data: StatusSummaryResponse
  status: 200
}

export type getStatusStatusIdSummaryResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type getStatusStatusIdSummaryResponseSuccess = (getStatusStatusIdSummaryResponse200) & {
  headers: Headers;
};
export type getStatusStatusIdSummaryResponseError = (getStatusStatusIdSummaryResponse500) & {
  headers: Headers;
};

export type getStatusStatusIdSummaryResponse = (getStatusStatusIdSummaryResponseSuccess | getStatusStatusIdSummaryResponseError)

export const getGetStatusStatusIdSummaryUrl = (statusId: string,
    params?: GetStatusStatusIdSummaryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/status/${statusId}/summary?${stringifiedParams}` : `/status/${statusId}/summary`
}

export const getStatusStatusIdSummary = async (statusId: string,
    params?: GetStatusStatusIdSummaryParams, options?: RequestInit): Promise<getStatusStatusIdSummaryResponse> => {
  
  const res = await fetch(getGetStatusStatusIdSummaryUrl(statusId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getStatusStatusIdSummaryResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getStatusStatusIdSummaryResponse
}





export const getGetStatusStatusIdSummaryQueryKey = (statusId?: string,
    params?: GetStatusStatusIdSummaryParams,) => {
    return [
    `/status/${statusId}/summary`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetStatusStatusIdSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getStatusStatusIdSummary>>, TError = ErrorResponse>(statusId: string,
    params?: GetStatusStatusIdSummaryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusIdSummary>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatusStatusIdSummaryQueryKey(statusId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatusStatusIdSummary>>> = ({ signal }) => getStatusStatusIdSummary(statusId,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(statusId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusIdSummary>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStatusStatusIdSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getStatusStatusIdSummary>>>
export type GetStatusStatusIdSummaryQueryError = ErrorResponse



export function useGetStatusStatusIdSummary<TData = Awaited<ReturnType<typeof getStatusStatusIdSummary>>, TError = ErrorResponse>(
 statusId: string,
    params?: GetStatusStatusIdSummaryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusIdSummary>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStatusStatusIdSummaryQueryOptions(statusId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type postStatusResponse201 = {
  data: CreateStatusLogsResponse
  status: 201
}

export type postStatusResponse400 = {
  data: ErrorResponse
  status: 400
}

export type postStatusResponse500 = {
  data: ErrorResponse
  status: 500
}
    
export type postStatusResponseSuccess = (postStatusResponse201) & {
  headers: Headers;
};
export type postStatusResponseError = (postStatusResponse400 | postStatusResponse500) & {
  headers: Headers;
};

export type postStatusResponse = (postStatusResponseSuccess | postStatusResponseError)

export const getPostStatusUrl = () => {


  

  return `/status`
}

export const postStatus = async (createStatusLogsRequest: CreateStatusLogsRequest, options?: RequestInit): Promise<postStatusResponse> => {
  
  const res = await fetch(getPostStatusUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createStatusLogsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postStatusResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postStatusResponse
}




export const getPostStatusMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postStatus>>, TError,{data: CreateStatusLogsRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postStatus>>, TError,{data: CreateStatusLogsRequest}, TContext> => {

const mutationKey = ['postStatus'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postStatus>>, {data: CreateStatusLogsRequest}> = (props) => {
          const {data} = props ?? {};

          return  postStatus(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostStatusMutationResult = NonNullable<Awaited<ReturnType<typeof postStatus>>>
    export type PostStatusMutationBody = CreateStatusLogsRequest
    export type PostStatusMutationError = ErrorResponse

    export const usePostStatus = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postStatus>>, TError,{data: CreateStatusLogsRequest}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postStatus>>,
        TError,
        {data: CreateStatusLogsRequest},
        TContext
      > => {

      const mutationOptions = getPostStatusMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
